This script uses the Rails routing mechanism to parse request URLs downloaded from the Canvas data redshift database. See 'dump_redshift/dump_requests.py' for the code to generate the request files.

The environment to run this code is rather involved; since we will be using the routing table generated by Canvas, we need to have an instance of Canvas installed (although not necessarily running) in order to use it. Here are the fastest steps that I followed to get to that point:

The script expects files to be laid out in a particular pattern(using a base directory $BASE):
  $BASE
    |- data/request-XXXX-XX-XX.csv
    |- canvas-data-tools/parse_request_urls

- Install Docker if necessary (www.docker.com)
- Download and run a Docker Canvas instance. I used the one at https://registry.hub.docker.com/u/lbjay/canvas-docker/
  - docker pull lbjay/canvas-docker
  - docker run -t -i -p 3000 --name canvas-docker -v $BASE/:/mnt/data lbjay/canvas-docker
This sets up and runs the Canvas instance in a VM. The -v parameter exports your local $BASE directory to /mnt/data in the docker image.

Connect to a shell on the docker image:
  - docker exec -i -t canvas-docker bash
  - cd /opt/canvas-lms/
  - ./bin/rails runner /mnt/data/canvas-data-tools/parse_request_urls/parse_request_urls.rb
The script runs in the context of the canvas-lms installation, and hooks into its routing mechanism to resolve the URLs in all request-XXXX-XX-XX.csv files in $BASE/data/. It generates two new files for each .csv file:
  $BASE
    |- request-XXXX-XX-XX.csv.paths
    |- request-XXXX-XX-XX.csv.bad_routes

The first contains the routing information, including the Canvas handler, action and parameters, indexed by request ID. The second contains details of any routes that could not be resolved.